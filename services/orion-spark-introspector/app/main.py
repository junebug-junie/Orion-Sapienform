from __future__ import annotations

import asyncio
import logging
import random
from datetime import datetime, timezone
from uuid import uuid4
from contextlib import asynccontextmanager

import uvicorn
from fastapi import FastAPI, WebSocket, WebSocketDisconnect, APIRouter
from fastapi.responses import FileResponse, RedirectResponse
from fastapi.staticfiles import StaticFiles

from orion.core.bus.async_service import OrionBusAsync
from orion.core.bus.bus_service_chassis import ChassisConfig, Hunter
from orion.core.bus.codec import OrionCodec

from .conn_manager import manager
from .settings import settings
from .worker import handle_candidate, handle_trace, set_publisher_bus

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("orion-spark-introspector")


def _cfg() -> ChassisConfig:
    return ChassisConfig(
        service_name=settings.service_name,
        service_version=settings.service_version,
        node_name=settings.node_name,
        bus_url=settings.orion_bus_url,
        bus_enabled=settings.orion_bus_enabled,
        heartbeat_interval_sec=settings.heartbeat_interval_sec,
    )


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Initialize shared publisher bus
    pub_bus = OrionBusAsync(settings.orion_bus_url, enabled=settings.orion_bus_enabled, codec=OrionCodec())
    await pub_bus.connect()

    # Pass bus to worker
    set_publisher_bus(pub_bus)

    async def multiplexer(env):
        if env.kind == "cognition.trace":
            await handle_trace(env)
        else:
            await handle_candidate(env)

    patterns = [settings.channel_spark_candidate, settings.channel_cognition_trace_pub]

    svc = Hunter(
        _cfg(),
        patterns=patterns,
        handler=multiplexer,
    )
    logger.info("Starting Spark Introspector Hunter patterns=%s", patterns)

    # Run Hunter in background
    hunter_task = asyncio.create_task(svc.start())

    yield

    # Cleanup
    hunter_task.cancel()
    try:
        await hunter_task
    except asyncio.CancelledError:
        pass
    await pub_bus.close()


app = FastAPI(lifespan=lifespan)

# Router for shared endpoints
router = APIRouter()

@router.get("/ui")
async def get_ui():
    return FileResponse("app/static/index.html")

@router.websocket("/ws/tissue")
async def websocket_endpoint(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        manager.disconnect(websocket)
    except Exception as e:
        logger.warning(f"WebSocket error: {e}")
        manager.disconnect(websocket)

@router.post("/api/test-pulse")
async def trigger_test_pulse():
    """Forces a random update to the connected UI clients to verify WS connection."""
    
    # 1. Tissue Update (Graph)
    tissue_payload = {
        "type": "tissue.update",
        "telemetry_id": str(uuid4()),
        "correlation_id": f"TEST-{str(uuid4())[:8]}",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "stats": {
            "phi": random.random(),
            "novelty": random.random(),
            "valence": random.random(),
            "arousal": random.random()
        },
        "metadata": {"source": "manual_test_pulse", "trace_verb": "pulse"}
    }
    
    # 2. Introspection Update (Text)
    intro_payload = {
        "type": "introspection.update",
        "correlation_id": tissue_payload["correlation_id"],
        "timestamp": tissue_payload["timestamp"],
        "text": "This is a simulated introspection generated by the Test Signal. If you see this, the websocket pipe for thoughts is active."
    }

    # Broadcast both
    await manager.broadcast(tissue_payload)
    await asyncio.sleep(0.1) # Small delay to ensure order
    await manager.broadcast(intro_payload)
    
    return {"status": "broadcast_sent", "payloads": [tissue_payload, intro_payload]}

# Include router at root (handles stripped prefix /spark -> /)
app.include_router(router)
# Include router with prefix (handles unstripped /spark/...)
app.include_router(router, prefix="/spark")

# Mount static files at both locations
app.mount("/static", StaticFiles(directory="app/static"), name="static")
app.mount("/spark/static", StaticFiles(directory="app/static"), name="static_spark")

# Redirects
@app.get("/")
async def root():
    return RedirectResponse(url="/spark/ui")

@app.get("/spark")
async def spark_root():
    return RedirectResponse(url="/spark/ui")

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=settings.port)
